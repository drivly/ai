{"version":3,"sources":["../../src/adapter/index.ts"],"sourcesContent":["import type { Adapter, BetterAuthOptions, Where } from 'better-auth'\nimport { BetterAuthError } from 'better-auth'\nimport { generateSchema } from './generate-schema'\nimport { createTransform } from './transform'\nimport type { PayloadAdapter } from './types'\n\nexport const BETTER_AUTH_CONTEXT_KEY = 'payload-db-adapter'\nconst PAYLOAD_QUERY_DEPTH = 2\n\nconst payloadAdapter: PayloadAdapter = (payloadClient, config = {}) => {\n  function debugLog(message: any[]) {\n    if (config.enableDebugLogs) {\n      console.log('[payload-db-adapter]', ...message)\n    }\n  }\n\n  function errorLog(message: any[]) {\n    console.error(`[payload-db-adapter]`, ...message)\n  }\n\n  function collectionSlugError(model: string) {\n    throw new BetterAuthError(\n      `Collection ${model} does not exist. Please check your payload collection slugs match the better auth schema`,\n    )\n  }\n\n  const createAdapterContext = (data: Record<string, any>) => ({\n    [BETTER_AUTH_CONTEXT_KEY]: { ...data },\n  })\n\n  async function resolvePayloadClient() {\n    const payload =\n      typeof payloadClient === 'function' ? await payloadClient() : await payloadClient\n    if (!payload.config?.custom?.hasBetterAuthPlugin) {\n      throw new BetterAuthError(\n        `Payload is not configured with the better-auth plugin. Please add the plugin to your payload config.`,\n      )\n    }\n    return payload\n  }\n\n  return (options: BetterAuthOptions): Adapter => {\n    const {\n      transformInput,\n      transformOutput,\n      convertWhereClause,\n      convertSelect,\n      convertSort,\n      getModelName,\n      singleIdQuery,\n      multipleIdsQuery,\n    } = createTransform(options, config.enableDebugLogs ?? false)\n\n    return {\n      id: 'payload',\n      async create<T extends Record<string, any>, R = T>(data: {\n        model: string\n        data: T\n        select?: string[]\n      }): Promise<R> {\n        const start = Date.now()\n        const { model, data: values, select } = data\n        const collectionSlug = getModelName(model)\n        const transformed = transformInput(values, model, 'create')\n        debugLog(['create', { collectionSlug, transformed, select }])\n        try {\n          const payload = await resolvePayloadClient()\n          if (!collectionSlug || !(collectionSlug in payload.collections)) {\n            collectionSlugError(model)\n          }\n          const result = await payload.create({\n            collection: collectionSlug,\n            data: transformed,\n            select: convertSelect(model, select),\n            context: createAdapterContext({ model, operation: 'create' }),\n            depth: PAYLOAD_QUERY_DEPTH,\n          })\n          const transformedResult = transformOutput(result)\n          debugLog([\n            'create result',\n            {\n              collectionSlug,\n              transformedResult,\n              duration: `${Date.now() - start}ms`,\n            },\n          ])\n          return transformedResult as R\n        } catch (error) {\n          errorLog(['Error in creating:', model, error])\n          return null as R\n        }\n      },\n      async findOne<T>(data: {\n        model: string\n        where: Where[]\n        select?: string[]\n      }): Promise<T | null> {\n        const start = Date.now()\n        const { model, where, select } = data\n        const collectionSlug = getModelName(model)\n        const payloadWhere = convertWhereClause(model, where)\n        debugLog(['findOne', { collectionSlug }])\n        try {\n          const payload = await resolvePayloadClient()\n          if (!collectionSlug || !(collectionSlug in payload.collections)) {\n            collectionSlugError(model)\n          }\n          const id = singleIdQuery(payloadWhere)\n          let result: Record<string, any> | null = null\n          if (id) {\n            debugLog(['findOneByID', { collectionSlug, id }])\n            const doc = await payload.findByID({\n              collection: collectionSlug,\n              id,\n              select: convertSelect(model, select),\n              context: createAdapterContext({\n                model,\n                operation: 'findOneByID',\n              }),\n              depth: PAYLOAD_QUERY_DEPTH,\n            })\n            result = doc\n          } else {\n            debugLog(['findOneByWhere', { collectionSlug, payloadWhere }])\n            const docs = await payload.find({\n              collection: collectionSlug,\n              where: payloadWhere,\n              select: convertSelect(model, select),\n              context: createAdapterContext({\n                model,\n                operation: 'findOneByWhere',\n              }),\n              depth: PAYLOAD_QUERY_DEPTH,\n              limit: 1,\n            })\n            result = docs.docs[0]\n          }\n          const transformedResult = result ? transformOutput(result) : null\n          debugLog([\n            'findOne result',\n            {\n              collectionSlug,\n              transformedResult,\n              duration: `${Date.now() - start}ms`,\n            },\n          ])\n          return transformedResult as T\n        } catch (error) {\n          errorLog(['Error in findOne: ', error])\n          return null\n        }\n      },\n      async findMany<T>(data: {\n        model: string\n        where?: Where[]\n        limit?: number\n        sortBy?: {\n          field: string\n          direction: 'asc' | 'desc'\n        }\n        offset?: number\n      }): Promise<T[]> {\n        const start = Date.now()\n        const { model, where, sortBy, limit, offset } = data\n        const collectionSlug = getModelName(model)\n        const payloadWhere = convertWhereClause(model, where)\n        debugLog(['findMany', { collectionSlug, sortBy, limit, offset }])\n        try {\n          const payload = await resolvePayloadClient()\n          if (!collectionSlug || !(collectionSlug in payload.collections)) {\n            collectionSlugError(model)\n          }\n          let result: {\n            docs: Record<string, any>[]\n            totalDocs: number\n          } | null = null\n          const multipleIds = where && multipleIdsQuery(payloadWhere)\n          const singleId = where && singleIdQuery(payloadWhere)\n          if (multipleIds && multipleIds.length > 0) {\n            debugLog(['findManyByMultipleIDs', { collectionSlug, ids: multipleIds }])\n            const res = {\n              docs: [] as Record<string, any>[],\n              totalDocs: 0,\n            }\n            for (const id of multipleIds) {\n              const doc = await payload.findByID({\n                collection: collectionSlug,\n                id,\n                depth: PAYLOAD_QUERY_DEPTH,\n                context: createAdapterContext({\n                  model,\n                  operation: 'findManyByMultipleIDs',\n                }),\n              })\n              res.docs.push(doc)\n              res.totalDocs++\n            }\n            result = { docs: res.docs, totalDocs: res.totalDocs }\n          } else if (singleId) {\n            debugLog(['findManyBySingleID', { collectionSlug, id: singleId }])\n            const doc = await payload.findByID({\n              collection: collectionSlug,\n              id: singleId,\n              depth: PAYLOAD_QUERY_DEPTH,\n              context: createAdapterContext({\n                model,\n                operation: 'findManyBySingleID',\n              }),\n            })\n            result = { docs: doc ? [doc] : [], totalDocs: doc ? 1 : 0 }\n          } else {\n            debugLog(['findManyByWhere', { collectionSlug, payloadWhere }])\n            const res = await payload.find({\n              collection: collectionSlug,\n              where: payloadWhere,\n              limit: limit,\n              page: offset ? Math.floor(offset / (limit || 10)) + 1 : 1,\n              sort: convertSort(model, sortBy),\n              depth: PAYLOAD_QUERY_DEPTH,\n              context: createAdapterContext({\n                model,\n                operation: 'findManyByWhere',\n              }),\n            })\n            result = { docs: res.docs, totalDocs: res.totalDocs }\n          }\n          const transformedResult = result?.docs.map((doc) => transformOutput(doc)) ?? null\n          debugLog([\n            'findMany result',\n            {\n              collectionSlug,\n              transformedResult,\n              duration: `${Date.now() - start}ms`,\n            },\n          ])\n          return transformedResult as T[]\n        } catch (error) {\n          errorLog(['Error in findMany: ', error])\n          return [] as T[]\n        }\n      },\n      async update<T>(data: {\n        model: string\n        where: Where[]\n        update: Record<string, unknown>\n      }): Promise<T | null> {\n        const start = Date.now()\n        const { model, where, update } = data\n        const collectionSlug = getModelName(model)\n        const payloadWhere = convertWhereClause(model, where)\n        debugLog(['update', { collectionSlug, update }])\n        try {\n          const payload = await resolvePayloadClient()\n          if (!collectionSlug || !(collectionSlug in payload.collections)) {\n            collectionSlugError(model)\n          }\n          let result: Record<string, any> | null = null\n          const id = singleIdQuery(payloadWhere)\n          if (id) {\n            debugLog(['updateByID', { collectionSlug, id }])\n            const doc = await payload.update({\n              collection: collectionSlug,\n              id,\n              data: update,\n              depth: PAYLOAD_QUERY_DEPTH,\n              context: createAdapterContext({ model, operation: 'updateByID' }),\n            })\n            result = doc\n          } else {\n            debugLog(['updateByWhere', { collectionSlug, payloadWhere }])\n            const doc = await payload.update({\n              collection: collectionSlug,\n              where: payloadWhere,\n              data: update,\n              depth: PAYLOAD_QUERY_DEPTH,\n              context: createAdapterContext({\n                model,\n                operation: 'updateByWhere',\n              }),\n            })\n            result = doc.docs[0]\n          }\n          const transformedResult = transformOutput(result) ?? null\n          debugLog([\n            'update result',\n            {\n              collectionSlug,\n              transformedResult,\n              duration: `${Date.now() - start}ms`,\n            },\n          ])\n          return transformedResult as T\n        } catch (error) {\n          errorLog(['Error in update: ', error])\n          return null\n        }\n      },\n      async updateMany(data: {\n        model: string\n        where: Where[]\n        update: Record<string, unknown>\n      }): Promise<number> {\n        const start = Date.now()\n        const { model, where, update } = data\n        const collectionSlug = getModelName(model)\n        const payloadWhere = convertWhereClause(model, where)\n        debugLog(['updateMany', { collectionSlug, payloadWhere, update }])\n        try {\n          const payload = await resolvePayloadClient()\n          if (!collectionSlug || !(collectionSlug in payload.collections)) {\n            collectionSlugError(model)\n          }\n          const { docs: updateResult } = await payload.update({\n            collection: collectionSlug,\n            where: payloadWhere,\n            data: update,\n            depth: PAYLOAD_QUERY_DEPTH,\n            context: createAdapterContext({ model, operation: 'updateMany' }),\n          })\n          debugLog([\n            'updateMany result',\n            {\n              collectionSlug,\n              result: updateResult,\n              duration: `${Date.now() - start}ms`,\n            },\n          ])\n          return updateResult?.length || 0\n        } catch (error) {\n          errorLog(['Error in updateMany: ', error])\n          return 0\n        }\n      },\n      async delete(data: { model: string; where: Where[] }): Promise<void> {\n        const start = Date.now()\n        const { model, where } = data\n        const collectionSlug = getModelName(model)\n        const payloadWhere = convertWhereClause(model, where)\n        debugLog(['delete', { collectionSlug }])\n        try {\n          const payload = await resolvePayloadClient()\n          if (!collectionSlug || !(collectionSlug in payload.collections)) {\n            collectionSlugError(model)\n          }\n          let deleteResult: {\n            doc: Record<string, any> | null\n            errors: any[]\n          } | null = null\n          const id = singleIdQuery(payloadWhere)\n          if (id) {\n            debugLog(['deleteByID', { collectionSlug, id }])\n            const doc = await payload.delete({\n              collection: collectionSlug,\n              id,\n              depth: PAYLOAD_QUERY_DEPTH,\n              context: createAdapterContext({ model, operation: 'deleteByID' }),\n            })\n            deleteResult = { doc, errors: [] }\n          } else {\n            debugLog(['deleteByWhere', { collectionSlug, payloadWhere }])\n            const doc = await payload.delete({\n              collection: collectionSlug,\n              where: payloadWhere,\n              depth: PAYLOAD_QUERY_DEPTH,\n              context: createAdapterContext({\n                model,\n                operation: 'deleteByWhere',\n              }),\n            })\n            deleteResult = { doc: doc.docs[0], errors: [] }\n          }\n          debugLog([\n            'delete result',\n            {\n              collectionSlug,\n              result: deleteResult,\n              duration: `${Date.now() - start}ms`,\n            },\n          ])\n          return\n        } catch (error) {\n          errorLog(['Error in delete: ', error])\n          return\n        }\n      },\n      async deleteMany(data: { model: string; where: Where[] }): Promise<number> {\n        const start = Date.now()\n        const { model, where } = data\n        const collectionSlug = getModelName(model)\n        const payloadWhere = convertWhereClause(model, where)\n        debugLog(['deleteMany', { collectionSlug, payloadWhere }])\n        try {\n          const payload = await resolvePayloadClient()\n          if (!collectionSlug || !(collectionSlug in payload.collections)) {\n            collectionSlugError(model)\n          }\n          const deleteResult = await payload.delete({\n            collection: collectionSlug,\n            where: payloadWhere,\n            depth: PAYLOAD_QUERY_DEPTH,\n            context: createAdapterContext({ model, operation: 'deleteMany' }),\n          })\n          debugLog([\n            'deleteMany result',\n            {\n              collectionSlug,\n              result: deleteResult,\n              duration: `${Date.now() - start}ms`,\n            },\n          ])\n          return deleteResult.docs.length\n        } catch (error) {\n          errorLog(['Error in deleteMany: ', error])\n          return 0\n        }\n      },\n      async count(data: { model: string; where?: Where[] }): Promise<number> {\n        const start = Date.now()\n        const { model, where } = data\n        const collectionSlug = getModelName(model)\n        const payloadWhere = convertWhereClause(model, where)\n        debugLog(['count', { collectionSlug, payloadWhere }])\n        try {\n          const payload = await resolvePayloadClient()\n          if (!collectionSlug || !(collectionSlug in payload.collections)) {\n            collectionSlugError(model)\n          }\n          const result = await payload.count({\n            collection: collectionSlug,\n            where: payloadWhere,\n            depth: PAYLOAD_QUERY_DEPTH,\n            context: createAdapterContext({ model, operation: 'count' }),\n          })\n          debugLog([\n            'count result',\n            {\n              collectionSlug,\n              result: { totalDocs: result.totalDocs },\n              duration: `${Date.now() - start}ms`,\n            },\n          ])\n          return result.totalDocs\n        } catch (error) {\n          errorLog(['Error in count: ', error])\n          return 0\n        }\n      },\n      createSchema: async (options, file) => {\n        const schemaCode = await generateSchema(options)\n\n        return {\n          code: schemaCode,\n          path: file || 'schema.ts',\n          append: false,\n          overwrite: true,\n        }\n      },\n      options: {\n        enableDebugLogs: config.enableDebugLogs,\n      },\n    }\n  }\n}\n\nexport { generateSchema, payloadAdapter }\n"],"names":["BetterAuthError","generateSchema","createTransform","BETTER_AUTH_CONTEXT_KEY","PAYLOAD_QUERY_DEPTH","payloadAdapter","payloadClient","config","debugLog","message","enableDebugLogs","console","log","errorLog","error","collectionSlugError","model","createAdapterContext","data","resolvePayloadClient","payload","custom","hasBetterAuthPlugin","options","transformInput","transformOutput","convertWhereClause","convertSelect","convertSort","getModelName","singleIdQuery","multipleIdsQuery","id","create","start","Date","now","values","select","collectionSlug","transformed","collections","result","collection","context","operation","depth","transformedResult","duration","findOne","where","payloadWhere","doc","findByID","docs","find","limit","findMany","sortBy","offset","multipleIds","singleId","length","ids","res","totalDocs","push","page","Math","floor","sort","map","update","updateMany","updateResult","delete","deleteResult","errors","deleteMany","count","createSchema","file","schemaCode","code","path","append","overwrite"],"mappings":"AACA,SAASA,eAAe,QAAQ,cAAa;AAC7C,SAASC,cAAc,QAAQ,oBAAmB;AAClD,SAASC,eAAe,QAAQ,cAAa;AAG7C,OAAO,MAAMC,0BAA0B,qBAAoB;AAC3D,MAAMC,sBAAsB;AAE5B,MAAMC,iBAAiC,CAACC,eAAeC,SAAS,CAAC,CAAC;IAChE,SAASC,SAASC,OAAc;QAC9B,IAAIF,OAAOG,eAAe,EAAE;YAC1BC,QAAQC,GAAG,CAAC,2BAA2BH;QACzC;IACF;IAEA,SAASI,SAASJ,OAAc;QAC9BE,QAAQG,KAAK,CAAC,CAAC,oBAAoB,CAAC,KAAKL;IAC3C;IAEA,SAASM,oBAAoBC,KAAa;QACxC,MAAM,IAAIhB,gBACR,CAAC,WAAW,EAAEgB,MAAM,wFAAwF,CAAC;IAEjH;IAEA,MAAMC,uBAAuB,CAACC,OAA+B,CAAA;YAC3D,CAACf,wBAAwB,EAAE;gBAAE,GAAGe,IAAI;YAAC;QACvC,CAAA;IAEA,eAAeC;QACb,MAAMC,UACJ,OAAOd,kBAAkB,aAAa,MAAMA,kBAAkB,MAAMA;QACtE,IAAI,CAACc,QAAQb,MAAM,EAAEc,QAAQC,qBAAqB;YAChD,MAAM,IAAItB,gBACR,CAAC,oGAAoG,CAAC;QAE1G;QACA,OAAOoB;IACT;IAEA,OAAO,CAACG;QACN,MAAM,EACJC,cAAc,EACdC,eAAe,EACfC,kBAAkB,EAClBC,aAAa,EACbC,WAAW,EACXC,YAAY,EACZC,aAAa,EACbC,gBAAgB,EACjB,GAAG7B,gBAAgBqB,SAAShB,OAAOG,eAAe,IAAI;QAEvD,OAAO;YACLsB,IAAI;YACJ,MAAMC,QAA6Cf,IAIlD;gBACC,MAAMgB,QAAQC,KAAKC,GAAG;gBACtB,MAAM,EAAEpB,KAAK,EAAEE,MAAMmB,MAAM,EAAEC,MAAM,EAAE,GAAGpB;gBACxC,MAAMqB,iBAAiBV,aAAab;gBACpC,MAAMwB,cAAchB,eAAea,QAAQrB,OAAO;gBAClDR,SAAS;oBAAC;oBAAU;wBAAE+B;wBAAgBC;wBAAaF;oBAAO;iBAAE;gBAC5D,IAAI;oBACF,MAAMlB,UAAU,MAAMD;oBACtB,IAAI,CAACoB,kBAAkB,CAAEA,CAAAA,kBAAkBnB,QAAQqB,WAAW,AAAD,GAAI;wBAC/D1B,oBAAoBC;oBACtB;oBACA,MAAM0B,SAAS,MAAMtB,QAAQa,MAAM,CAAC;wBAClCU,YAAYJ;wBACZrB,MAAMsB;wBACNF,QAAQX,cAAcX,OAAOsB;wBAC7BM,SAAS3B,qBAAqB;4BAAED;4BAAO6B,WAAW;wBAAS;wBAC3DC,OAAO1C;oBACT;oBACA,MAAM2C,oBAAoBtB,gBAAgBiB;oBAC1ClC,SAAS;wBACP;wBACA;4BACE+B;4BACAQ;4BACAC,UAAU,GAAGb,KAAKC,GAAG,KAAKF,MAAM,EAAE,CAAC;wBACrC;qBACD;oBACD,OAAOa;gBACT,EAAE,OAAOjC,OAAO;oBACdD,SAAS;wBAAC;wBAAsBG;wBAAOF;qBAAM;oBAC7C,OAAO;gBACT;YACF;YACA,MAAMmC,SAAW/B,IAIhB;gBACC,MAAMgB,QAAQC,KAAKC,GAAG;gBACtB,MAAM,EAAEpB,KAAK,EAAEkC,KAAK,EAAEZ,MAAM,EAAE,GAAGpB;gBACjC,MAAMqB,iBAAiBV,aAAab;gBACpC,MAAMmC,eAAezB,mBAAmBV,OAAOkC;gBAC/C1C,SAAS;oBAAC;oBAAW;wBAAE+B;oBAAe;iBAAE;gBACxC,IAAI;oBACF,MAAMnB,UAAU,MAAMD;oBACtB,IAAI,CAACoB,kBAAkB,CAAEA,CAAAA,kBAAkBnB,QAAQqB,WAAW,AAAD,GAAI;wBAC/D1B,oBAAoBC;oBACtB;oBACA,MAAMgB,KAAKF,cAAcqB;oBACzB,IAAIT,SAAqC;oBACzC,IAAIV,IAAI;wBACNxB,SAAS;4BAAC;4BAAe;gCAAE+B;gCAAgBP;4BAAG;yBAAE;wBAChD,MAAMoB,MAAM,MAAMhC,QAAQiC,QAAQ,CAAC;4BACjCV,YAAYJ;4BACZP;4BACAM,QAAQX,cAAcX,OAAOsB;4BAC7BM,SAAS3B,qBAAqB;gCAC5BD;gCACA6B,WAAW;4BACb;4BACAC,OAAO1C;wBACT;wBACAsC,SAASU;oBACX,OAAO;wBACL5C,SAAS;4BAAC;4BAAkB;gCAAE+B;gCAAgBY;4BAAa;yBAAE;wBAC7D,MAAMG,OAAO,MAAMlC,QAAQmC,IAAI,CAAC;4BAC9BZ,YAAYJ;4BACZW,OAAOC;4BACPb,QAAQX,cAAcX,OAAOsB;4BAC7BM,SAAS3B,qBAAqB;gCAC5BD;gCACA6B,WAAW;4BACb;4BACAC,OAAO1C;4BACPoD,OAAO;wBACT;wBACAd,SAASY,KAAKA,IAAI,CAAC,EAAE;oBACvB;oBACA,MAAMP,oBAAoBL,SAASjB,gBAAgBiB,UAAU;oBAC7DlC,SAAS;wBACP;wBACA;4BACE+B;4BACAQ;4BACAC,UAAU,GAAGb,KAAKC,GAAG,KAAKF,MAAM,EAAE,CAAC;wBACrC;qBACD;oBACD,OAAOa;gBACT,EAAE,OAAOjC,OAAO;oBACdD,SAAS;wBAAC;wBAAsBC;qBAAM;oBACtC,OAAO;gBACT;YACF;YACA,MAAM2C,UAAYvC,IASjB;gBACC,MAAMgB,QAAQC,KAAKC,GAAG;gBACtB,MAAM,EAAEpB,KAAK,EAAEkC,KAAK,EAAEQ,MAAM,EAAEF,KAAK,EAAEG,MAAM,EAAE,GAAGzC;gBAChD,MAAMqB,iBAAiBV,aAAab;gBACpC,MAAMmC,eAAezB,mBAAmBV,OAAOkC;gBAC/C1C,SAAS;oBAAC;oBAAY;wBAAE+B;wBAAgBmB;wBAAQF;wBAAOG;oBAAO;iBAAE;gBAChE,IAAI;oBACF,MAAMvC,UAAU,MAAMD;oBACtB,IAAI,CAACoB,kBAAkB,CAAEA,CAAAA,kBAAkBnB,QAAQqB,WAAW,AAAD,GAAI;wBAC/D1B,oBAAoBC;oBACtB;oBACA,IAAI0B,SAGO;oBACX,MAAMkB,cAAcV,SAASnB,iBAAiBoB;oBAC9C,MAAMU,WAAWX,SAASpB,cAAcqB;oBACxC,IAAIS,eAAeA,YAAYE,MAAM,GAAG,GAAG;wBACzCtD,SAAS;4BAAC;4BAAyB;gCAAE+B;gCAAgBwB,KAAKH;4BAAY;yBAAE;wBACxE,MAAMI,MAAM;4BACVV,MAAM,EAAE;4BACRW,WAAW;wBACb;wBACA,KAAK,MAAMjC,MAAM4B,YAAa;4BAC5B,MAAMR,MAAM,MAAMhC,QAAQiC,QAAQ,CAAC;gCACjCV,YAAYJ;gCACZP;gCACAc,OAAO1C;gCACPwC,SAAS3B,qBAAqB;oCAC5BD;oCACA6B,WAAW;gCACb;4BACF;4BACAmB,IAAIV,IAAI,CAACY,IAAI,CAACd;4BACdY,IAAIC,SAAS;wBACf;wBACAvB,SAAS;4BAAEY,MAAMU,IAAIV,IAAI;4BAAEW,WAAWD,IAAIC,SAAS;wBAAC;oBACtD,OAAO,IAAIJ,UAAU;wBACnBrD,SAAS;4BAAC;4BAAsB;gCAAE+B;gCAAgBP,IAAI6B;4BAAS;yBAAE;wBACjE,MAAMT,MAAM,MAAMhC,QAAQiC,QAAQ,CAAC;4BACjCV,YAAYJ;4BACZP,IAAI6B;4BACJf,OAAO1C;4BACPwC,SAAS3B,qBAAqB;gCAC5BD;gCACA6B,WAAW;4BACb;wBACF;wBACAH,SAAS;4BAAEY,MAAMF,MAAM;gCAACA;6BAAI,GAAG,EAAE;4BAAEa,WAAWb,MAAM,IAAI;wBAAE;oBAC5D,OAAO;wBACL5C,SAAS;4BAAC;4BAAmB;gCAAE+B;gCAAgBY;4BAAa;yBAAE;wBAC9D,MAAMa,MAAM,MAAM5C,QAAQmC,IAAI,CAAC;4BAC7BZ,YAAYJ;4BACZW,OAAOC;4BACPK,OAAOA;4BACPW,MAAMR,SAASS,KAAKC,KAAK,CAACV,SAAUH,CAAAA,SAAS,EAAC,KAAM,IAAI;4BACxDc,MAAM1C,YAAYZ,OAAO0C;4BACzBZ,OAAO1C;4BACPwC,SAAS3B,qBAAqB;gCAC5BD;gCACA6B,WAAW;4BACb;wBACF;wBACAH,SAAS;4BAAEY,MAAMU,IAAIV,IAAI;4BAAEW,WAAWD,IAAIC,SAAS;wBAAC;oBACtD;oBACA,MAAMlB,oBAAoBL,QAAQY,KAAKiB,IAAI,CAACnB,MAAQ3B,gBAAgB2B,SAAS;oBAC7E5C,SAAS;wBACP;wBACA;4BACE+B;4BACAQ;4BACAC,UAAU,GAAGb,KAAKC,GAAG,KAAKF,MAAM,EAAE,CAAC;wBACrC;qBACD;oBACD,OAAOa;gBACT,EAAE,OAAOjC,OAAO;oBACdD,SAAS;wBAAC;wBAAuBC;qBAAM;oBACvC,OAAO,EAAE;gBACX;YACF;YACA,MAAM0D,QAAUtD,IAIf;gBACC,MAAMgB,QAAQC,KAAKC,GAAG;gBACtB,MAAM,EAAEpB,KAAK,EAAEkC,KAAK,EAAEsB,MAAM,EAAE,GAAGtD;gBACjC,MAAMqB,iBAAiBV,aAAab;gBACpC,MAAMmC,eAAezB,mBAAmBV,OAAOkC;gBAC/C1C,SAAS;oBAAC;oBAAU;wBAAE+B;wBAAgBiC;oBAAO;iBAAE;gBAC/C,IAAI;oBACF,MAAMpD,UAAU,MAAMD;oBACtB,IAAI,CAACoB,kBAAkB,CAAEA,CAAAA,kBAAkBnB,QAAQqB,WAAW,AAAD,GAAI;wBAC/D1B,oBAAoBC;oBACtB;oBACA,IAAI0B,SAAqC;oBACzC,MAAMV,KAAKF,cAAcqB;oBACzB,IAAInB,IAAI;wBACNxB,SAAS;4BAAC;4BAAc;gCAAE+B;gCAAgBP;4BAAG;yBAAE;wBAC/C,MAAMoB,MAAM,MAAMhC,QAAQoD,MAAM,CAAC;4BAC/B7B,YAAYJ;4BACZP;4BACAd,MAAMsD;4BACN1B,OAAO1C;4BACPwC,SAAS3B,qBAAqB;gCAAED;gCAAO6B,WAAW;4BAAa;wBACjE;wBACAH,SAASU;oBACX,OAAO;wBACL5C,SAAS;4BAAC;4BAAiB;gCAAE+B;gCAAgBY;4BAAa;yBAAE;wBAC5D,MAAMC,MAAM,MAAMhC,QAAQoD,MAAM,CAAC;4BAC/B7B,YAAYJ;4BACZW,OAAOC;4BACPjC,MAAMsD;4BACN1B,OAAO1C;4BACPwC,SAAS3B,qBAAqB;gCAC5BD;gCACA6B,WAAW;4BACb;wBACF;wBACAH,SAASU,IAAIE,IAAI,CAAC,EAAE;oBACtB;oBACA,MAAMP,oBAAoBtB,gBAAgBiB,WAAW;oBACrDlC,SAAS;wBACP;wBACA;4BACE+B;4BACAQ;4BACAC,UAAU,GAAGb,KAAKC,GAAG,KAAKF,MAAM,EAAE,CAAC;wBACrC;qBACD;oBACD,OAAOa;gBACT,EAAE,OAAOjC,OAAO;oBACdD,SAAS;wBAAC;wBAAqBC;qBAAM;oBACrC,OAAO;gBACT;YACF;YACA,MAAM2D,YAAWvD,IAIhB;gBACC,MAAMgB,QAAQC,KAAKC,GAAG;gBACtB,MAAM,EAAEpB,KAAK,EAAEkC,KAAK,EAAEsB,MAAM,EAAE,GAAGtD;gBACjC,MAAMqB,iBAAiBV,aAAab;gBACpC,MAAMmC,eAAezB,mBAAmBV,OAAOkC;gBAC/C1C,SAAS;oBAAC;oBAAc;wBAAE+B;wBAAgBY;wBAAcqB;oBAAO;iBAAE;gBACjE,IAAI;oBACF,MAAMpD,UAAU,MAAMD;oBACtB,IAAI,CAACoB,kBAAkB,CAAEA,CAAAA,kBAAkBnB,QAAQqB,WAAW,AAAD,GAAI;wBAC/D1B,oBAAoBC;oBACtB;oBACA,MAAM,EAAEsC,MAAMoB,YAAY,EAAE,GAAG,MAAMtD,QAAQoD,MAAM,CAAC;wBAClD7B,YAAYJ;wBACZW,OAAOC;wBACPjC,MAAMsD;wBACN1B,OAAO1C;wBACPwC,SAAS3B,qBAAqB;4BAAED;4BAAO6B,WAAW;wBAAa;oBACjE;oBACArC,SAAS;wBACP;wBACA;4BACE+B;4BACAG,QAAQgC;4BACR1B,UAAU,GAAGb,KAAKC,GAAG,KAAKF,MAAM,EAAE,CAAC;wBACrC;qBACD;oBACD,OAAOwC,cAAcZ,UAAU;gBACjC,EAAE,OAAOhD,OAAO;oBACdD,SAAS;wBAAC;wBAAyBC;qBAAM;oBACzC,OAAO;gBACT;YACF;YACA,MAAM6D,QAAOzD,IAAuC;gBAClD,MAAMgB,QAAQC,KAAKC,GAAG;gBACtB,MAAM,EAAEpB,KAAK,EAAEkC,KAAK,EAAE,GAAGhC;gBACzB,MAAMqB,iBAAiBV,aAAab;gBACpC,MAAMmC,eAAezB,mBAAmBV,OAAOkC;gBAC/C1C,SAAS;oBAAC;oBAAU;wBAAE+B;oBAAe;iBAAE;gBACvC,IAAI;oBACF,MAAMnB,UAAU,MAAMD;oBACtB,IAAI,CAACoB,kBAAkB,CAAEA,CAAAA,kBAAkBnB,QAAQqB,WAAW,AAAD,GAAI;wBAC/D1B,oBAAoBC;oBACtB;oBACA,IAAI4D,eAGO;oBACX,MAAM5C,KAAKF,cAAcqB;oBACzB,IAAInB,IAAI;wBACNxB,SAAS;4BAAC;4BAAc;gCAAE+B;gCAAgBP;4BAAG;yBAAE;wBAC/C,MAAMoB,MAAM,MAAMhC,QAAQuD,MAAM,CAAC;4BAC/BhC,YAAYJ;4BACZP;4BACAc,OAAO1C;4BACPwC,SAAS3B,qBAAqB;gCAAED;gCAAO6B,WAAW;4BAAa;wBACjE;wBACA+B,eAAe;4BAAExB;4BAAKyB,QAAQ,EAAE;wBAAC;oBACnC,OAAO;wBACLrE,SAAS;4BAAC;4BAAiB;gCAAE+B;gCAAgBY;4BAAa;yBAAE;wBAC5D,MAAMC,MAAM,MAAMhC,QAAQuD,MAAM,CAAC;4BAC/BhC,YAAYJ;4BACZW,OAAOC;4BACPL,OAAO1C;4BACPwC,SAAS3B,qBAAqB;gCAC5BD;gCACA6B,WAAW;4BACb;wBACF;wBACA+B,eAAe;4BAAExB,KAAKA,IAAIE,IAAI,CAAC,EAAE;4BAAEuB,QAAQ,EAAE;wBAAC;oBAChD;oBACArE,SAAS;wBACP;wBACA;4BACE+B;4BACAG,QAAQkC;4BACR5B,UAAU,GAAGb,KAAKC,GAAG,KAAKF,MAAM,EAAE,CAAC;wBACrC;qBACD;oBACD;gBACF,EAAE,OAAOpB,OAAO;oBACdD,SAAS;wBAAC;wBAAqBC;qBAAM;oBACrC;gBACF;YACF;YACA,MAAMgE,YAAW5D,IAAuC;gBACtD,MAAMgB,QAAQC,KAAKC,GAAG;gBACtB,MAAM,EAAEpB,KAAK,EAAEkC,KAAK,EAAE,GAAGhC;gBACzB,MAAMqB,iBAAiBV,aAAab;gBACpC,MAAMmC,eAAezB,mBAAmBV,OAAOkC;gBAC/C1C,SAAS;oBAAC;oBAAc;wBAAE+B;wBAAgBY;oBAAa;iBAAE;gBACzD,IAAI;oBACF,MAAM/B,UAAU,MAAMD;oBACtB,IAAI,CAACoB,kBAAkB,CAAEA,CAAAA,kBAAkBnB,QAAQqB,WAAW,AAAD,GAAI;wBAC/D1B,oBAAoBC;oBACtB;oBACA,MAAM4D,eAAe,MAAMxD,QAAQuD,MAAM,CAAC;wBACxChC,YAAYJ;wBACZW,OAAOC;wBACPL,OAAO1C;wBACPwC,SAAS3B,qBAAqB;4BAAED;4BAAO6B,WAAW;wBAAa;oBACjE;oBACArC,SAAS;wBACP;wBACA;4BACE+B;4BACAG,QAAQkC;4BACR5B,UAAU,GAAGb,KAAKC,GAAG,KAAKF,MAAM,EAAE,CAAC;wBACrC;qBACD;oBACD,OAAO0C,aAAatB,IAAI,CAACQ,MAAM;gBACjC,EAAE,OAAOhD,OAAO;oBACdD,SAAS;wBAAC;wBAAyBC;qBAAM;oBACzC,OAAO;gBACT;YACF;YACA,MAAMiE,OAAM7D,IAAwC;gBAClD,MAAMgB,QAAQC,KAAKC,GAAG;gBACtB,MAAM,EAAEpB,KAAK,EAAEkC,KAAK,EAAE,GAAGhC;gBACzB,MAAMqB,iBAAiBV,aAAab;gBACpC,MAAMmC,eAAezB,mBAAmBV,OAAOkC;gBAC/C1C,SAAS;oBAAC;oBAAS;wBAAE+B;wBAAgBY;oBAAa;iBAAE;gBACpD,IAAI;oBACF,MAAM/B,UAAU,MAAMD;oBACtB,IAAI,CAACoB,kBAAkB,CAAEA,CAAAA,kBAAkBnB,QAAQqB,WAAW,AAAD,GAAI;wBAC/D1B,oBAAoBC;oBACtB;oBACA,MAAM0B,SAAS,MAAMtB,QAAQ2D,KAAK,CAAC;wBACjCpC,YAAYJ;wBACZW,OAAOC;wBACPL,OAAO1C;wBACPwC,SAAS3B,qBAAqB;4BAAED;4BAAO6B,WAAW;wBAAQ;oBAC5D;oBACArC,SAAS;wBACP;wBACA;4BACE+B;4BACAG,QAAQ;gCAAEuB,WAAWvB,OAAOuB,SAAS;4BAAC;4BACtCjB,UAAU,GAAGb,KAAKC,GAAG,KAAKF,MAAM,EAAE,CAAC;wBACrC;qBACD;oBACD,OAAOQ,OAAOuB,SAAS;gBACzB,EAAE,OAAOnD,OAAO;oBACdD,SAAS;wBAAC;wBAAoBC;qBAAM;oBACpC,OAAO;gBACT;YACF;YACAkE,cAAc,OAAOzD,SAAS0D;gBAC5B,MAAMC,aAAa,MAAMjF,eAAesB;gBAExC,OAAO;oBACL4D,MAAMD;oBACNE,MAAMH,QAAQ;oBACdI,QAAQ;oBACRC,WAAW;gBACb;YACF;YACA/D,SAAS;gBACPb,iBAAiBH,OAAOG,eAAe;YACzC;QACF;IACF;AACF;AAEA,SAAST,cAAc,EAAEI,cAAc,GAAE"}