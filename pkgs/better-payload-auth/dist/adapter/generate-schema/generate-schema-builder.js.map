{"version":3,"sources":["../../../src/adapter/generate-schema/generate-schema-builder.ts"],"sourcesContent":["/**\n * This module generates PayloadCMS collection configurations based on the Better Auth schema.\n *\n * The generated collection configs include:\n * - Users: For user management with proper auth configuration\n * - Sessions: For maintaining user sessions\n * - Accounts: For OAuth provider accounts\n * - VerificationTokens: For email verification or social sign in\n *\n * Each collection is properly formatted with:\n * - Appropriate field types (text, relationship, checkbox, etc.)\n * - Admin configuration for better UI experience\n * - Auth configuration for the Users collection\n * - Proper field relationships between collections\n *\n * Users can copy these generated collection configs to their PayloadCMS project\n * and add authentication strategies as needed.\n */\nimport type { BetterAuthOptions } from 'better-auth'\nimport { getAuthTables } from 'better-auth/db'\nimport type { CollectionConfig, Field } from 'payload'\nimport { format } from 'prettier'\n\nexport const generateSchemaBuilderStage = async ({\n  BAOptions,\n  code,\n}: {\n  code: string\n  BAOptions: BetterAuthOptions\n}) => {\n  const formattedCode = await format(code, { filepath: 'schema.ts' })\n\n  const { post, collections } = parseExistingSchema(formattedCode)\n\n  const payloadSchemaStr = generatePayloadCollectionConfigs({\n    options: BAOptions,\n    collections,\n    exports: post,\n  })\n\n  return await format(`${payloadSchemaStr}`, {\n    filepath: 'schema.ts',\n  })\n}\n\nfunction parseExistingSchema(code: string): {\n  collections: CollectionConfig[]\n  post: string\n} {\n  const collections: CollectionConfig[] = []\n  let post = ''\n\n  // Extract collection definitions\n  const collectionRegex =\n    /const\\s+([A-Z][a-zA-Z0-9]*)\\s*:\\s*CollectionConfig\\s*=\\s*{[\\s\\S]*?}\\s*as\\s*const;/g\n  let match\n  while ((match = collectionRegex.exec(code)) !== null) {\n    const collectionName = match[1]\n    const collectionDef = match[0]\n\n    // Extract slug\n    const slugMatch = collectionDef.match(/slug:\\s*\"([^\"]+)\"/)\n    const slug = slugMatch ? slugMatch[1] : collectionName.toLowerCase()\n\n    // Extract useAsTitle\n    const titleMatch = collectionDef.match(/useAsTitle:\\s*\"([^\"]+)\"/)\n    const useAsTitle = titleMatch ? titleMatch[1] : 'id'\n\n    // Extract fields\n    const fieldsRegex = /fields:\\s*\\[([\\s\\S]*?)\\],/\n    const fieldsMatch = collectionDef.match(fieldsRegex)\n    const fields: Field[] = []\n\n    if (fieldsMatch) {\n      const fieldBlockRegex = /{[\\s\\S]*?},/g\n      const fieldBlocks = fieldsMatch[1].match(fieldBlockRegex) || []\n\n      for (const fieldBlock of fieldBlocks) {\n        const nameMatch = fieldBlock.match(/name:\\s*\"([^\"]+)\"/)\n        const typeMatch = fieldBlock.match(/type:\\s*\"([^\"]+)\"/)\n        const requiredMatch = fieldBlock.match(/required:\\s*(true|false)/)\n        const uniqueMatch = fieldBlock.match(/unique:\\s*(true|false)/)\n        const relationToMatch = fieldBlock.match(/relationTo:\\s*\"([^\"]+)\"/)\n\n        if (nameMatch && typeMatch) {\n          const field = {\n            name: nameMatch[1],\n            type: typeMatch[1] as Field['type'],\n          }\n\n          if (requiredMatch) {\n            ;(field as any).required = requiredMatch[1] === 'true'\n          }\n\n          if (uniqueMatch) {\n            ;(field as any).unique = uniqueMatch[1] === 'true'\n          }\n\n          if (relationToMatch) {\n            ;(field as any).relationTo = relationToMatch[1]\n          }\n\n          fields.push(field as Field)\n        }\n      }\n    }\n\n    // Check for timestamps\n    const timestampsMatch = collectionDef.match(/timestamps:\\s*(true|false)/)\n    const hasTimestamps = timestampsMatch ? timestampsMatch[1] === 'true' : false\n\n    collections.push({\n      slug,\n      admin: {\n        useAsTitle,\n      },\n      fields,\n      ...(hasTimestamps && { timestamps: true }),\n    })\n  }\n\n  // Extract export statement\n  const exportRegex = /export\\s*{[\\s\\S]*?};/\n  const exportMatch = code.match(exportRegex)\n  if (exportMatch) {\n    post = exportMatch[0]\n  }\n\n  return { collections, post }\n}\n\nfunction generatePayloadCollectionConfigs({\n  options,\n  collections,\n  exports,\n}: {\n  options: BetterAuthOptions\n  collections: CollectionConfig[]\n  exports: string\n}): string {\n  let result = ''\n\n  // add pre message and import statements\n  result += `/**\n * EXAMPLE COLLECTIONS FOR BETTER AUTH\n * \n * Below is what your Payload collections should look like.\n * Please copy these to your actual collection configs.\n * Make sure to add an authStrategy for the users collection if there is one.\n * \n * Example auth strategy:\n * auth: {\n *   disableLocalStrategy: true,\n *   strategies: [\n *     betterAuthStrategy(),\n *     // Add other strategies as needed\n *   ],\n * },\n */\nimport type { CollectionConfig } from 'payload';\n\n`\n\n  // add the collections\n  let collectionsStr = ''\n  const tables = getAuthTables(options)\n\n  // Process existing collections first\n  const existingCollectionsBySlug = collections.reduce(\n    (acc, collection) => {\n      if (collection.slug) {\n        acc[collection.slug] = collection\n      }\n      return acc\n    },\n    {} as Record<string, CollectionConfig>,\n  )\n\n  for (const [tableKey, table] of Object.entries(tables)) {\n    const modelName = table.modelName\n    const capitalized = modelName.charAt(0).toUpperCase() + modelName.slice(1)\n\n    // Check if this collection already exists in the provided collections\n    const existingCollection = existingCollectionsBySlug[modelName]\n\n    if (existingCollection) {\n      // Convert existing collection to string representation\n      collectionsStr += `const ${capitalized}: CollectionConfig = ${JSON.stringify(existingCollection, null, 2).replace(/\"([^\"]+)\":/g, '$1:')} as const;\\n\\n`\n      continue\n    }\n\n    // Create new collection if it doesn't exist\n    collectionsStr += `const ${capitalized}: CollectionConfig = {\n  slug: \"${modelName}\",\n`\n\n    // Add admin section for better UX\n    collectionsStr += `  admin: {\n    useAsTitle: \"${getNameField(table.fields)}\",\n  },\n`\n\n    // Add auth section ONLY for users collection\n    if (modelName === 'users') {\n      collectionsStr += `  auth: {\n    disableLocalStrategy: true,\n    strategies: [],\n    // Add your auth strategies here if needed\n  },\n`\n    }\n\n    // Add fields\n    collectionsStr += `  fields: [\n`\n\n    for (const [fieldKey, field] of Object.entries(table.fields)) {\n      const fieldName = field.fieldName || fieldKey\n      // Skip id field as Payload handles it automatically\n      if (fieldName === 'id') continue\n\n      if (fieldName === 'createdAt' || fieldName === 'updatedAt') continue\n\n      // Handle field type mapping with safer type approach\n      let fieldType = mapFieldType(field.type as string, fieldName)\n      const isRelationship = fieldName.endsWith('_id') || !!field.references?.model\n\n      collectionsStr += `    {\n      name: \"${isRelationship ? fieldName.replace('_id', '') : fieldName}\",\n`\n\n      if (isRelationship) {\n        collectionsStr += `      type: \"relationship\",\n      relationTo: \"${field.references?.model || fieldName.replace('_id', '')}\",\n`\n      } else if (fieldType === 'upload') {\n        collectionsStr += `      type: \"upload\",\n      relationTo: \"media\",\n`\n      } else {\n        collectionsStr += `      type: \"${fieldType}\",\n`\n      }\n\n      if (field.required) {\n        collectionsStr += `      required: true,\n`\n      }\n\n      if (field.unique) {\n        collectionsStr += `      unique: true,\n`\n      }\n\n      // Check if field has options and fieldType is select\n      if (fieldType === 'select' && 'options' in field && Array.isArray(field.options)) {\n        collectionsStr += `      options: ${JSON.stringify(field.options)},\n`\n      }\n\n      if (field.defaultValue !== undefined) {\n        if (typeof field.defaultValue === 'string') {\n          collectionsStr += `      defaultValue: \"${field.defaultValue}\",\n`\n        } else if (typeof field.defaultValue === 'boolean') {\n          collectionsStr += `      defaultValue: ${field.defaultValue ? 'true' : 'false'},\n`\n        } else if (\n          field.defaultValue &&\n          typeof field.defaultValue === 'function' &&\n          field.defaultValue.toString().includes('() => !1')\n        ) {\n          // Handle function-like default values with are false\n          collectionsStr += `      defaultValue: false,\n`\n        } else if (\n          field.defaultValue &&\n          typeof field.defaultValue === 'function' &&\n          field.defaultValue.toString().includes('() => !0')\n        ) {\n          // Handle function-like default values with are true\n          collectionsStr += `      defaultValue: true,\n`\n        } else {\n          collectionsStr += `      defaultValue: ${field.defaultValue},\n`\n        }\n      }\n\n      // Add admin section for fields if needed - safely check for admin property\n      if (\n        'admin' in field &&\n        field.admin &&\n        typeof field.admin === 'object' &&\n        'readOnly' in field.admin &&\n        field.admin.readOnly\n      ) {\n        collectionsStr += `      admin: {\n        readOnly: true,\n      },\n`\n      }\n\n      collectionsStr += `    },\n`\n    }\n\n    collectionsStr += `  ],\n  timestamps: true,\n} as const;\n\n`\n  }\n\n  // Add any collections from the input that aren't in the tables\n  for (const collection of collections) {\n    if (!collection.slug || tables[collection.slug]) {\n      continue // Skip if no slug or already processed\n    }\n\n    const capitalized = collection.slug.charAt(0).toUpperCase() + collection.slug.slice(1)\n    collectionsStr += `const ${capitalized}: CollectionConfig = ${JSON.stringify(collection, null, 2).replace(/\"([^\"]+)\":/g, '$1:')} as const;\\n\\n`\n  }\n\n  result += collectionsStr\n\n  // Add export statements for all collections\n  // Check if we have an existing export statement to adapt\n  if (exports && exports.trim()) {\n    // Parse the existing exports to get collection names\n    const existingExportMatch = exports.match(/export\\s*{\\s*(.*?)\\s*}/)\n    const existingCollections = existingExportMatch\n      ? existingExportMatch[1].split(',').map((name) => name.trim())\n      : []\n\n    // Get the collection names from our tables\n    const tableCollections = Object.keys(tables).map((model) => {\n      return model.charAt(0).toUpperCase() + model.slice(1)\n    })\n\n    // Combine existing and new collections, removing duplicates\n    const allCollections = [...new Set([...existingCollections, ...tableCollections])]\n\n    // Create the new export statement\n    result += `export { ${allCollections.join(', ')} };\n`\n  } else if (Object.keys(tables).length > 0) {\n    const collectionNames = Object.keys(tables).map((model) => {\n      // Convert model name to PascalCase for export\n      const pascalCase = model.charAt(0).toUpperCase() + model.slice(1)\n      return pascalCase\n    })\n\n    result += `export { ${collectionNames.join(', ')} };\n`\n  } else {\n    result += `export {};\n`\n  }\n\n  return result\n}\n\n// Helper functions\nfunction mapFieldType(type: string, fieldName: string): string {\n  if (fieldName.endsWith('_id')) return 'relationship'\n\n  switch (type) {\n    case 'boolean':\n      return 'checkbox'\n    case 'number':\n      return 'number'\n    case 'string':\n      if (fieldName === 'email') return 'email'\n      if (fieldName.includes('password')) return 'text'\n      if (fieldName.includes('image') || fieldName.includes('avatar')) return 'upload'\n      return 'text'\n    case 'date':\n      return 'date'\n    case 'array':\n      return 'array'\n    default:\n      return 'text'\n  }\n}\n\nfunction getNameField(fields: Record<string, any>): string {\n  // Try to find an appropriate field to use as title\n  const nameOptions = ['name', 'title', 'label', 'email', 'username']\n\n  for (const option of nameOptions) {\n    if (Object.keys(fields).includes(option)) {\n      return option\n    }\n  }\n\n  // Default to first field that's not id\n  const firstNonIdField = Object.keys(fields).find((k) => k !== 'id')\n  return firstNonIdField || 'id'\n}\n"],"names":["getAuthTables","format","generateSchemaBuilderStage","BAOptions","code","formattedCode","filepath","post","collections","parseExistingSchema","payloadSchemaStr","generatePayloadCollectionConfigs","options","exports","collectionRegex","match","exec","collectionName","collectionDef","slugMatch","slug","toLowerCase","titleMatch","useAsTitle","fieldsRegex","fieldsMatch","fields","fieldBlockRegex","fieldBlocks","fieldBlock","nameMatch","typeMatch","requiredMatch","uniqueMatch","relationToMatch","field","name","type","required","unique","relationTo","push","timestampsMatch","hasTimestamps","admin","timestamps","exportRegex","exportMatch","result","collectionsStr","tables","existingCollectionsBySlug","reduce","acc","collection","tableKey","table","Object","entries","modelName","capitalized","charAt","toUpperCase","slice","existingCollection","JSON","stringify","replace","getNameField","fieldKey","fieldName","fieldType","mapFieldType","isRelationship","endsWith","references","model","Array","isArray","defaultValue","undefined","toString","includes","readOnly","trim","existingExportMatch","existingCollections","split","map","tableCollections","keys","allCollections","Set","join","length","collectionNames","pascalCase","nameOptions","option","firstNonIdField","find","k"],"mappings":"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"}