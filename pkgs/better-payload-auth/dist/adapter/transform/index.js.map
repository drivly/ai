{"version":3,"sources":["../../../src/adapter/transform/index.ts"],"sourcesContent":["import type { BetterAuthOptions, Where } from 'better-auth'\nimport { BetterAuthError } from 'better-auth'\nimport { getAuthTables } from 'better-auth/db'\nimport type { CollectionSlug, Where as PayloadWhere } from 'payload'\n\nexport const createTransform = (options: BetterAuthOptions, enableDebugLogs: boolean) => {\n  const schema = getAuthTables(options)\n\n  function debugLog(message: any[]) {\n    if (enableDebugLogs) {\n      console.log(`[payload-db-adapter]`, ...message)\n    }\n  }\n\n  function getField(model: string, field: string) {\n    if (field === 'id') {\n      return field\n    }\n    const f = (schema as Record<string, any>)[model]?.fields[field]\n    const fieldName = f?.fieldName || field\n    debugLog(['getField: ', model, fieldName])\n    return fieldName\n  }\n\n  function getModelName(model: string): CollectionSlug {\n    const collection = (schema as Record<string, any>)[model]?.modelName || model\n    if (!collection) {\n      throw new BetterAuthError(`Model ${model} does not exist in the database.`)\n    }\n    return collection as CollectionSlug\n  }\n\n  function singleIdQuery(where: PayloadWhere) {\n    if (!where || 'and' in where || 'or' in where) return null\n\n    // For a single id query like { id: { equals: 15 } }\n    // First, check if there's an id field in the where clause\n    if ('id' in where || '_id' in where) {\n      const idField = 'id' in where ? 'id' : '_id'\n      const condition = where[idField]\n\n      // Check if condition is an object with equals operator\n      if (\n        condition &&\n        typeof condition === 'object' &&\n        !Array.isArray(condition) &&\n        'equals' in condition\n      ) {\n        const value = condition.equals\n        if (typeof value === 'string' || typeof value === 'number') {\n          return value\n        }\n      }\n\n      // Check for contains operator with single value\n      if (\n        condition &&\n        typeof condition === 'object' &&\n        !Array.isArray(condition) &&\n        'contains' in condition &&\n        Array.isArray(condition.contains) &&\n        condition.contains.length === 1\n      ) {\n        const value = condition.contains[0]\n        if (typeof value === 'string' || typeof value === 'number') {\n          return value\n        }\n      }\n    }\n\n    return null\n  }\n\n  function multipleIdsQuery(where: PayloadWhere) {\n    if (!where || 'and' in where || 'or' in where) return null\n    if ('id' in where || '_id' in where) {\n      const idField = 'id' in where ? 'id' : '_id'\n      const condition = where[idField]\n\n      // Check if this is an 'in' operator with id field and array of values\n      if (\n        condition &&\n        typeof condition === 'object' &&\n        !Array.isArray(condition) &&\n        'in' in condition &&\n        Array.isArray(condition.in) &&\n        condition.in.length > 1 &&\n        condition.in.every((id: unknown) => typeof id === 'string' || typeof id === 'number')\n      ) {\n        return condition.in as (number | string)[]\n      }\n\n      // Also check for contains operator with array of IDs\n      if (\n        condition &&\n        typeof condition === 'object' &&\n        !Array.isArray(condition) &&\n        'contains' in condition &&\n        Array.isArray(condition.contains) &&\n        condition.contains.length > 1 &&\n        condition.contains.every((id: unknown) => typeof id === 'string' || typeof id === 'number')\n      ) {\n        return condition.contains as (number | string)[]\n      }\n    }\n\n    return null\n  }\n\n  function transformInput(data: Record<string, any>, model: string, action: 'create' | 'update') {\n    const transformedData: Record<string, any> = {}\n    const schemaFields = (schema as Record<string, any>)[model].fields\n    for (const dataField in data) {\n      if (data[dataField] === undefined && action === 'update') {\n        continue\n      }\n      const updatedFieldName = schemaFields[dataField]?.fieldName\n\n      if (updatedFieldName) {\n        if (\n          schemaFields[dataField].type === 'string' &&\n          typeof data[dataField] === 'number' &&\n          updatedFieldName.endsWith('Id')\n        ) {\n          debugLog([\n            'Incoming data is typeof number but stored as typeof string',\n            dataField,\n            data[dataField].toString(),\n          ])\n          transformedData[updatedFieldName] = data[dataField].toString()\n        } else {\n          transformedData[updatedFieldName] = data[dataField]\n        }\n      } else {\n        transformedData[dataField] = data[dataField]\n      }\n    }\n\n    return transformedData\n  }\n\n  function transformOutput<T extends Record<string, any> | undefined>(doc: T): T {\n    if (!doc || typeof doc !== 'object') return doc\n\n    const result = { ...doc } as any\n\n    // Scan for relationship fields that contain objects with IDs\n    Object.entries(doc).forEach(([key, value]) => {\n      // If the value is an object with an id property, it's likely a relationship\n      if (value && typeof value === 'object' && 'id' in value) {\n        // Create a new field with Id suffix containing just the ID\n        const newKey = `${key}Id`\n        result[newKey] = value.id\n\n        //also remove the object and just keep the id\n        result[key] = value.id\n\n        // Keep the original value as well for backward compatibility\n      } else if (Array.isArray(value)) {\n        // Handle arrays of relationships\n        if (value.length > 0 && typeof value[0] === 'object' && 'id' in value[0]) {\n          const newKey = `${key}Ids`\n          result[newKey] = value.map((item) => item.id)\n\n          //also remove the object and just keep the id\n          result[key] = value.map((item) => item.id)\n        }\n      }\n    })\n\n    // Scan for date fields and convert them to Date objects\n    Object.entries(result).forEach(([key, value]) => {\n      // Check if the field is a date string (ISO format)\n      if (\n        typeof value === 'string' &&\n        /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{3})?Z$/.test(value)\n      ) {\n        result[key] = new Date(value)\n      } else if (\n        // Also check for date-like field names\n        (key.endsWith('At') || key.endsWith('Date') || key === 'date') &&\n        typeof value === 'string' &&\n        !isNaN(Date.parse(value))\n      ) {\n        result[key] = new Date(value)\n      }\n    })\n\n    return result as T\n  }\n\n  function operatorToPayload(operator: string, value: any) {\n    switch (operator) {\n      case 'eq':\n        return { equals: value }\n      case 'ne':\n        return { not_equals: value }\n      case 'gt':\n        return { greater_than: value }\n      case 'gte':\n        return { greater_than_equal: value }\n      case 'lt':\n        return { less_than: value }\n      case 'lte':\n        return { less_than_equal: value }\n      case 'contains':\n        return { contains: value }\n      case 'in':\n        return { in: value }\n      case 'starts_with':\n        return { like: `${value}%` }\n      case 'ends_with':\n        return { like: `%${value}` }\n      default:\n        return { equals: value }\n    }\n  }\n\n  function convertWhereValue(value: any, field: string) {\n    if (field === 'id' || field === '_id') {\n      if (typeof value === 'object') {\n        return value.id\n      }\n      return value\n    }\n    return value\n  }\n\n  function convertWhereClause(model: string, where?: Where[]): PayloadWhere {\n    if (!where) return {}\n    if (where.length === 1) {\n      const w = where[0]\n      if (!w) {\n        return {}\n      }\n\n      const field = getField(model, w.field)\n      const value = convertWhereValue(w.value, field)\n\n      const res = {\n        [field]: operatorToPayload(w.operator ?? '', value),\n      }\n\n      return res\n    }\n    const and = where.filter((w) => w.connector === 'AND' || !w.connector)\n    const or = where.filter((w) => w.connector === 'OR')\n    const andClause = and.map((w) => {\n      const field = getField(model, w.field)\n      const value = convertWhereValue(w.value, field)\n      return {\n        [field]: operatorToPayload(w.operator ?? '', value),\n      }\n    })\n    const orClause = or.map((w) => {\n      const field = getField(model, w.field)\n      const value = convertWhereValue(w.value, field)\n      return {\n        [field]: operatorToPayload(w.operator ?? '', value),\n      }\n    })\n\n    return {\n      ...(andClause.length ? { AND: andClause } : {}),\n      ...(orClause.length ? { OR: orClause } : {}),\n    }\n  }\n\n  function convertSelect(model: string, select?: string[]) {\n    if (!select || select.length === 0) return undefined\n    return select.reduce((acc, field) => ({ ...acc, [getField(model, field)]: true }), {})\n  }\n\n  function convertSort(model: string, sortBy?: { field: string; direction: 'asc' | 'desc' }) {\n    if (!sortBy) return undefined\n    return `${sortBy.direction === 'desc' ? '-' : ''}${getField(model, sortBy.field)}`\n  }\n\n  return {\n    getField,\n    getModelName,\n    singleIdQuery,\n    multipleIdsQuery,\n    transformInput,\n    transformOutput,\n    convertWhereClause,\n    convertSelect,\n    convertSort,\n  }\n}\n"],"names":["BetterAuthError","getAuthTables","createTransform","options","enableDebugLogs","schema","debugLog","message","console","log","getField","model","field","f","fields","fieldName","getModelName","collection","modelName","singleIdQuery","where","idField","condition","Array","isArray","value","equals","contains","length","multipleIdsQuery","in","every","id","transformInput","data","action","transformedData","schemaFields","dataField","undefined","updatedFieldName","type","endsWith","toString","transformOutput","doc","result","Object","entries","forEach","key","newKey","map","item","test","Date","isNaN","parse","operatorToPayload","operator","not_equals","greater_than","greater_than_equal","less_than","less_than_equal","like","convertWhereValue","convertWhereClause","w","res","and","filter","connector","or","andClause","orClause","AND","OR","convertSelect","select","reduce","acc","convertSort","sortBy","direction"],"mappings":"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"}