{"version":3,"sources":["../../../../../src/plugin/collections/users/hooks/after-login.ts"],"sourcesContent":["import { generateId, Session } from 'better-auth'\nimport { createAuthMiddleware } from 'better-auth/api'\nimport { setCookieCache } from 'better-auth/cookies'\nimport { parseSetCookie, type ResponseCookie } from 'next/dist/compiled/@edge-runtime/cookies'\nimport { cookies } from 'next/headers'\nimport { CollectionAfterLoginHook } from 'payload'\nimport { getPayloadAuth } from '../../../lib/get-payload-auth'\nimport { getIp } from '../../../helpers/get-ip'\nimport { prepareSessionData } from '../../../lib/prepare-session-data'\n\ntype AfterLoginOptions = {\n  usersCollectionSlug: string\n  sessionsCollectionSlug: string\n}\n\n/**\n * This hook is used to sync the admin login token with better-auth session token\n * It also creates a new session in better-auth\n */\nexport const getAfterLoginHook = (options: AfterLoginOptions): CollectionAfterLoginHook => {\n  const hook: CollectionAfterLoginHook = async ({ collection, context, req, token, user }) => {\n    const config = req.payload.config\n    const payload = await getPayloadAuth(config)\n    const cookieStore = await cookies()\n    const authContext = await payload.betterAuth.$context\n\n    const sessionExpiration = payload.betterAuth.options.session?.expiresIn || 60 * 60 * 24 * 7 // 7 days\n    // we can't use internal adapter as we can cause a race condition unless we pass req to the payload.create\n    const session = (await payload.create({\n      collection: options.sessionsCollectionSlug,\n      data: {\n        ipAddress: getIp(req.headers, payload.betterAuth.options) || '',\n        userAgent: req.headers?.get('user-agent') || '',\n        user: user.id,\n        token: generateId(32),\n        expiresAt: new Date(Date.now() + sessionExpiration * 1000),\n      },\n      req,\n    })) as Session\n\n    const betterAuthHandleRequest = createAuthMiddleware(async (ctx): Promise<Headers | null> => {\n      ctx.context = { ...authContext, user: user }\n      await ctx.setSignedCookie(\n        ctx.context.authCookies.sessionToken.name,\n        session.token,\n        ctx.context.secret,\n        ctx.context.authCookies.sessionToken.options,\n      )\n      const filteredSessionData = await prepareSessionData({\n        newSession: { session, user },\n        payloadConfig: config,\n        collectionSlugs: {\n          userCollectionSlug: options.usersCollectionSlug,\n          sessionCollectionSlug: options.sessionsCollectionSlug,\n        },\n      })\n      await setCookieCache(ctx, filteredSessionData as any)\n      if ('responseHeaders' in ctx) {\n        return ctx.responseHeaders as Headers\n      }\n      return null\n    })\n\n    const responseHeaders = await betterAuthHandleRequest(req)\n    const responseCookies = responseHeaders\n      ?.getSetCookie()\n      .map((cookie) => parseSetCookie(cookie))\n      .filter(Boolean) as ResponseCookie[]\n\n    if (responseCookies) {\n      for (const cookieData of responseCookies) {\n        const { name, value, ...options } = cookieData\n        cookieStore.set({\n          ...options,\n          name,\n          value: decodeURIComponent(value),\n        })\n      }\n    }\n  }\n\n  return hook as CollectionAfterLoginHook\n}\n"],"names":["generateId","createAuthMiddleware","setCookieCache","parseSetCookie","cookies","getPayloadAuth","getIp","prepareSessionData","getAfterLoginHook","options","hook","collection","context","req","token","user","config","payload","cookieStore","authContext","betterAuth","$context","sessionExpiration","session","expiresIn","create","sessionsCollectionSlug","data","ipAddress","headers","userAgent","get","id","expiresAt","Date","now","betterAuthHandleRequest","ctx","setSignedCookie","authCookies","sessionToken","name","secret","filteredSessionData","newSession","payloadConfig","collectionSlugs","userCollectionSlug","usersCollectionSlug","sessionCollectionSlug","responseHeaders","responseCookies","getSetCookie","map","cookie","filter","Boolean","cookieData","value","set","decodeURIComponent"],"mappings":"AAAA,SAASA,UAAU,QAAiB,cAAa;AACjD,SAASC,oBAAoB,QAAQ,kBAAiB;AACtD,SAASC,cAAc,QAAQ,sBAAqB;AACpD,SAASC,cAAc,QAA6B,2CAA0C;AAC9F,SAASC,OAAO,QAAQ,eAAc;AAEtC,SAASC,cAAc,QAAQ,gCAA+B;AAC9D,SAASC,KAAK,QAAQ,0BAAyB;AAC/C,SAASC,kBAAkB,QAAQ,oCAAmC;AAOtE;;;CAGC,GACD,OAAO,MAAMC,oBAAoB,CAACC;IAChC,MAAMC,OAAiC,OAAO,EAAEC,UAAU,EAAEC,OAAO,EAAEC,GAAG,EAAEC,KAAK,EAAEC,IAAI,EAAE;QACrF,MAAMC,SAASH,IAAII,OAAO,CAACD,MAAM;QACjC,MAAMC,UAAU,MAAMZ,eAAeW;QACrC,MAAME,cAAc,MAAMd;QAC1B,MAAMe,cAAc,MAAMF,QAAQG,UAAU,CAACC,QAAQ;QAErD,MAAMC,oBAAoBL,QAAQG,UAAU,CAACX,OAAO,CAACc,OAAO,EAAEC,aAAa,KAAK,KAAK,KAAK,EAAE,SAAS;;QACrG,0GAA0G;QAC1G,MAAMD,UAAW,MAAMN,QAAQQ,MAAM,CAAC;YACpCd,YAAYF,QAAQiB,sBAAsB;YAC1CC,MAAM;gBACJC,WAAWtB,MAAMO,IAAIgB,OAAO,EAAEZ,QAAQG,UAAU,CAACX,OAAO,KAAK;gBAC7DqB,WAAWjB,IAAIgB,OAAO,EAAEE,IAAI,iBAAiB;gBAC7ChB,MAAMA,KAAKiB,EAAE;gBACblB,OAAOd,WAAW;gBAClBiC,WAAW,IAAIC,KAAKA,KAAKC,GAAG,KAAKb,oBAAoB;YACvD;YACAT;QACF;QAEA,MAAMuB,0BAA0BnC,qBAAqB,OAAOoC;YAC1DA,IAAIzB,OAAO,GAAG;gBAAE,GAAGO,WAAW;gBAAEJ,MAAMA;YAAK;YAC3C,MAAMsB,IAAIC,eAAe,CACvBD,IAAIzB,OAAO,CAAC2B,WAAW,CAACC,YAAY,CAACC,IAAI,EACzClB,QAAQT,KAAK,EACbuB,IAAIzB,OAAO,CAAC8B,MAAM,EAClBL,IAAIzB,OAAO,CAAC2B,WAAW,CAACC,YAAY,CAAC/B,OAAO;YAE9C,MAAMkC,sBAAsB,MAAMpC,mBAAmB;gBACnDqC,YAAY;oBAAErB;oBAASR;gBAAK;gBAC5B8B,eAAe7B;gBACf8B,iBAAiB;oBACfC,oBAAoBtC,QAAQuC,mBAAmB;oBAC/CC,uBAAuBxC,QAAQiB,sBAAsB;gBACvD;YACF;YACA,MAAMxB,eAAemC,KAAKM;YAC1B,IAAI,qBAAqBN,KAAK;gBAC5B,OAAOA,IAAIa,eAAe;YAC5B;YACA,OAAO;QACT;QAEA,MAAMA,kBAAkB,MAAMd,wBAAwBvB;QACtD,MAAMsC,kBAAkBD,iBACpBE,eACDC,IAAI,CAACC,SAAWnD,eAAemD,SAC/BC,OAAOC;QAEV,IAAIL,iBAAiB;YACnB,KAAK,MAAMM,cAAcN,gBAAiB;gBACxC,MAAM,EAAEV,IAAI,EAAEiB,KAAK,EAAE,GAAGjD,SAAS,GAAGgD;gBACpCvC,YAAYyC,GAAG,CAAC;oBACd,GAAGlD,OAAO;oBACVgC;oBACAiB,OAAOE,mBAAmBF;gBAC5B;YACF;QACF;IACF;IAEA,OAAOhD;AACT,EAAC"}