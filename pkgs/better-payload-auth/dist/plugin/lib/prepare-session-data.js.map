{"version":3,"sources":["../../../src/plugin/lib/prepare-session-data.ts"],"sourcesContent":["import { getFieldsToSign } from 'payload'\nimport type { Config, Payload } from 'payload'\n\ntype CollectionSlugs = {\n  userCollectionSlug: string\n  sessionCollectionSlug: string\n}\n\n/**\n * Prepares session data for cookie cache by filtering user and session objects\n * based on the payload configuration's 'saveToJwt' property\n */\nexport async function prepareSessionData({\n  newSession,\n  payloadConfig,\n  collectionSlugs,\n}: {\n  newSession: {\n    user: any\n    session: any\n  }\n  payloadConfig: Payload['config'] | Config\n  collectionSlugs: CollectionSlugs\n}) {\n  if (!newSession || !newSession.user) {\n    return null\n  }\n\n  const { userCollectionSlug, sessionCollectionSlug } = collectionSlugs\n\n  const userCollection = payloadConfig?.collections?.find((c) => c.slug === userCollectionSlug)\n  const sessionCollection = payloadConfig?.collections?.find(\n    (c) => c.slug === sessionCollectionSlug,\n  )\n\n  if (!userCollection) {\n    throw new Error(`User collection with slug '${userCollectionSlug}' not found`)\n  }\n\n  const filteredUser = getFieldsToSign({\n    collectionConfig: userCollection,\n    email: newSession.user.email,\n    user: newSession.user,\n  })\n\n  let filteredSession = newSession.session\n  const isImpersonated = newSession.session.impersonatedBy\n  if (sessionCollection && newSession.session) {\n    filteredSession = getFieldsToSign({\n      collectionConfig: sessionCollection,\n      email: newSession.user.email,\n      user: newSession.session,\n    }) as typeof newSession.session\n\n    // getFieldsToSign is meant for auth collections so we remove the email and collection fields\n    delete filteredSession.email\n    delete filteredSession.collection\n  }\n\n  if (isImpersonated) {\n    filteredSession.impersonatedBy = newSession.session.impersonatedBy\n  }\n\n  return {\n    ...newSession,\n    user: filteredUser,\n    session: filteredSession,\n  }\n}\n"],"names":["getFieldsToSign","prepareSessionData","newSession","payloadConfig","collectionSlugs","user","userCollectionSlug","sessionCollectionSlug","userCollection","collections","find","c","slug","sessionCollection","Error","filteredUser","collectionConfig","email","filteredSession","session","isImpersonated","impersonatedBy","collection"],"mappings":"AAAA,SAASA,eAAe,QAAQ,UAAS;AAQzC;;;CAGC,GACD,OAAO,eAAeC,mBAAmB,EACvCC,UAAU,EACVC,aAAa,EACbC,eAAe,EAQhB;IACC,IAAI,CAACF,cAAc,CAACA,WAAWG,IAAI,EAAE;QACnC,OAAO;IACT;IAEA,MAAM,EAAEC,kBAAkB,EAAEC,qBAAqB,EAAE,GAAGH;IAEtD,MAAMI,iBAAiBL,eAAeM,aAAaC,KAAK,CAACC,IAAMA,EAAEC,IAAI,KAAKN;IAC1E,MAAMO,oBAAoBV,eAAeM,aAAaC,KACpD,CAACC,IAAMA,EAAEC,IAAI,KAAKL;IAGpB,IAAI,CAACC,gBAAgB;QACnB,MAAM,IAAIM,MAAM,CAAC,2BAA2B,EAAER,mBAAmB,WAAW,CAAC;IAC/E;IAEA,MAAMS,eAAef,gBAAgB;QACnCgB,kBAAkBR;QAClBS,OAAOf,WAAWG,IAAI,CAACY,KAAK;QAC5BZ,MAAMH,WAAWG,IAAI;IACvB;IAEA,IAAIa,kBAAkBhB,WAAWiB,OAAO;IACxC,MAAMC,iBAAiBlB,WAAWiB,OAAO,CAACE,cAAc;IACxD,IAAIR,qBAAqBX,WAAWiB,OAAO,EAAE;QAC3CD,kBAAkBlB,gBAAgB;YAChCgB,kBAAkBH;YAClBI,OAAOf,WAAWG,IAAI,CAACY,KAAK;YAC5BZ,MAAMH,WAAWiB,OAAO;QAC1B;QAEA,6FAA6F;QAC7F,OAAOD,gBAAgBD,KAAK;QAC5B,OAAOC,gBAAgBI,UAAU;IACnC;IAEA,IAAIF,gBAAgB;QAClBF,gBAAgBG,cAAc,GAAGnB,WAAWiB,OAAO,CAACE,cAAc;IACpE;IAEA,OAAO;QACL,GAAGnB,UAAU;QACbG,MAAMU;QACNI,SAASD;IACX;AACF"}