{"version":3,"sources":["../../../src/plugin/lib/password.ts"],"sourcesContent":["import crypto from 'crypto'\n\n/**\n * Mimics Payload's internal password hashing using pbkdf2\n *\n * This generates a hash compatible with Payload's internal auth system\n * so that passwords set via better-auth can be used with Payload admin panel\n */\nfunction pbkdf2Promisified(password: string, salt: string): Promise<Buffer> {\n  return new Promise((resolve, reject) =>\n    crypto.pbkdf2(password, salt, 25000, 512, 'sha256', (err, hashRaw) =>\n      err ? reject(err) : resolve(hashRaw),\n    ),\n  )\n}\n\n/**\n * Generates random bytes for the salt\n */\nfunction randomBytes(): Promise<Buffer> {\n  return new Promise((resolve, reject) =>\n    crypto.randomBytes(32, (err, saltBuffer) => (err ? reject(err) : resolve(saltBuffer))),\n  )\n}\n\n/**\n * Custom implementation of password hashing that matches Payload's format\n *\n * Instead of using better-auth's scrypt, this uses pbkdf2 with the same\n * parameters as Payload CMS\n *\n * @param password The password to hash\n * @returns A string in the format {salt}:{hash}\n */\nexport const hashPassword = async (password: string): Promise<string> => {\n  const saltBuffer = await randomBytes()\n  const salt = saltBuffer.toString('hex')\n\n  const hashRaw = await pbkdf2Promisified(password, salt)\n  const hash = hashRaw.toString('hex')\n\n  return `${salt}:${hash}`\n}\n\n/**\n * Verifies a password against a stored hash\n *\n * This function is flexible and can handle:\n * 1. A combined string in format {salt}:{hash} (for account passwords)\n * 2. When salt and hash need to be combined from user records\n *\n * @param params Object containing the hash and password\n * @returns Boolean indicating if the password matches\n */\nexport const verifyPassword = async ({\n  hash,\n  password,\n  salt,\n}: {\n  hash: string\n  password: string\n  salt?: string\n}): Promise<boolean> => {\n  let saltValue: string\n  let storedHash: string\n\n  // If salt is provided separately (from user record), use it with the hash\n  if (salt) {\n    saltValue = salt\n    storedHash = hash\n  } else {\n    // Otherwise, split the combined format (from account.password)\n    const parts = hash.split(':')\n    if (parts.length !== 2) {\n      return false\n    }\n    ;[saltValue, storedHash] = parts\n  }\n\n  if (!saltValue || !storedHash) {\n    return false\n  }\n\n  const hashRaw = await pbkdf2Promisified(password, saltValue)\n  const computedHash = hashRaw.toString('hex')\n\n  return storedHash === computedHash\n}\n"],"names":["crypto","pbkdf2Promisified","password","salt","Promise","resolve","reject","pbkdf2","err","hashRaw","randomBytes","saltBuffer","hashPassword","toString","hash","verifyPassword","saltValue","storedHash","parts","split","length","computedHash"],"mappings":"AAAA,OAAOA,YAAY,SAAQ;AAE3B;;;;;CAKC,GACD,SAASC,kBAAkBC,QAAgB,EAAEC,IAAY;IACvD,OAAO,IAAIC,QAAQ,CAACC,SAASC,SAC3BN,OAAOO,MAAM,CAACL,UAAUC,MAAM,OAAO,KAAK,UAAU,CAACK,KAAKC,UACxDD,MAAMF,OAAOE,OAAOH,QAAQI;AAGlC;AAEA;;CAEC,GACD,SAASC;IACP,OAAO,IAAIN,QAAQ,CAACC,SAASC,SAC3BN,OAAOU,WAAW,CAAC,IAAI,CAACF,KAAKG,aAAgBH,MAAMF,OAAOE,OAAOH,QAAQM;AAE7E;AAEA;;;;;;;;CAQC,GACD,OAAO,MAAMC,eAAe,OAAOV;IACjC,MAAMS,aAAa,MAAMD;IACzB,MAAMP,OAAOQ,WAAWE,QAAQ,CAAC;IAEjC,MAAMJ,UAAU,MAAMR,kBAAkBC,UAAUC;IAClD,MAAMW,OAAOL,QAAQI,QAAQ,CAAC;IAE9B,OAAO,GAAGV,KAAK,CAAC,EAAEW,MAAM;AAC1B,EAAC;AAED;;;;;;;;;CASC,GACD,OAAO,MAAMC,iBAAiB,OAAO,EACnCD,IAAI,EACJZ,QAAQ,EACRC,IAAI,EAKL;IACC,IAAIa;IACJ,IAAIC;IAEJ,0EAA0E;IAC1E,IAAId,MAAM;QACRa,YAAYb;QACZc,aAAaH;IACf,OAAO;QACL,+DAA+D;QAC/D,MAAMI,QAAQJ,KAAKK,KAAK,CAAC;QACzB,IAAID,MAAME,MAAM,KAAK,GAAG;YACtB,OAAO;QACT;;QACC,CAACJ,WAAWC,WAAW,GAAGC;IAC7B;IAEA,IAAI,CAACF,aAAa,CAACC,YAAY;QAC7B,OAAO;IACT;IAEA,MAAMR,UAAU,MAAMR,kBAAkBC,UAAUc;IAClD,MAAMK,eAAeZ,QAAQI,QAAQ,CAAC;IAEtC,OAAOI,eAAeI;AACxB,EAAC"}