{"version":3,"sources":["../../../src/plugin/helpers/serialize-cookie.ts"],"sourcesContent":["import { subtle } from 'uncrypto'\n\ntype CookiePrefixOptions = 'host' | 'secure'\n\ntype CookieOptions = {\n  /**\n   * Domain of the cookie\n   *\n   * The Domain attribute specifies which server can receive a cookie. If specified, cookies are\n   * available on the specified server and its subdomains. If the it is not\n   * specified, the cookies are available on the server that sets it but not on\n   * its subdomains.\n   *\n   * @example\n   * `domain: \"example.com\"`\n   */\n  domain?: string\n  /**\n   * A lifetime of a cookie. Permanent cookies are deleted after the date specified in the\n   * Expires attribute:\n   *\n   * Expires has been available for longer than Max-Age, however Max-Age is less error-prone, and\n   * takes precedence when both are set. The rationale behind this is that when you set an\n   * Expires date and time, they're relative to the client the cookie is being set on. If the\n   * server is set to a different time, this could cause errors\n   */\n  expires?: Date\n  /**\n   * Forbids JavaScript from accessing the cookie, for example, through the Document.cookie\n   * property. Note that a cookie that has been created with HttpOnly will still be sent with\n   * JavaScript-initiated requests, for example, when calling XMLHttpRequest.send() or fetch().\n   * This mitigates attacks against cross-site scripting\n   */\n  httpOnly?: boolean\n  /**\n   * Indicates the number of seconds until the cookie expires. A zero or negative number will\n   * expire the cookie immediately. If both Expires and Max-Age are set, Max-Age has precedence.\n   *\n   * @example 604800 - 7 days\n   */\n  maxAge?: number\n  /**\n   * Indicates the path that must exist in the requested URL for the browser to send the Cookie\n   * header.\n   *\n   * @example\n   * \"/docs\"\n   * // -> the request paths /docs, /docs/, /docs/Web/, and /docs/Web/HTTP will all match. the request paths /, /fr/docs will not match.\n   */\n  path?: string\n  /**\n   * Indicates that the cookie is sent to the server only when a request is made with the https:\n   * scheme (except on localhost), and therefore, is more resistant to man-in-the-middle attacks.\n   */\n  secure?: boolean\n  /**\n   * Controls whether or not a cookie is sent with cross-site requests, providing some protection\n   * against cross-site request forgery attacks (CSRF).\n   *\n   * Strict -  Means that the browser sends the cookie only for same-site requests, that is,\n   * requests originating from the same site that set the cookie. If a request originates from a\n   * different domain or scheme (even with the same domain), no cookies with the SameSite=Strict\n   * attribute are sent.\n   *\n   * Lax - Means that the cookie is not sent on cross-site requests, such as on requests to load\n   * images or frames, but is sent when a user is navigating to the origin site from an external\n   * site (for example, when following a link). This is the default behavior if the SameSite\n   * attribute is not specified.\n   *\n   * None - Means that the browser sends the cookie with both cross-site and same-site requests.\n   * The Secure attribute must also be set when setting this value.\n   */\n  sameSite?: 'Strict' | 'Lax' | 'None' | 'strict' | 'lax' | 'none'\n  /**\n   * Indicates that the cookie should be stored using partitioned storage. Note that if this is\n   * set, the Secure directive must also be set.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/Privacy/Privacy_sandbox/Partitioned_cookies\n   */\n  partitioned?: boolean\n  /**\n   * Cooke Prefix\n   *\n   * - secure: `__Secure-` -> `__Secure-cookie-name`\n   * - host: `__Host-` -> `__Host-cookie-name`\n   *\n   * `secure` must be set to true to use prefixes\n   */\n  prefix?: CookiePrefixOptions\n}\n\nexport const verifySignature = async (\n  base64Signature: string,\n  value: string,\n  secret: CryptoKey,\n): Promise<boolean> => {\n  try {\n    const signatureBinStr = atob(base64Signature)\n    const signature = new Uint8Array(signatureBinStr.length)\n    for (let i = 0, len = signatureBinStr.length; i < len; i++) {\n      signature[i] = signatureBinStr.charCodeAt(i)\n    }\n    return await subtle.verify(algorithm, secret, signature, new TextEncoder().encode(value))\n  } catch (e) {\n    return false\n  }\n}\n\nconst _serialize = (key: string, value: string, opt: CookieOptions = {}) => {\n  let cookie: string\n\n  if (opt?.prefix === 'secure') {\n    cookie = `${`__Secure-${key}`}=${value}`\n  } else if (opt?.prefix === 'host') {\n    cookie = `${`__Host-${key}`}=${value}`\n  } else {\n    cookie = `${key}=${value}`\n  }\n\n  if (key.startsWith('__Secure-') && !opt.secure) {\n    opt.secure = true\n  }\n\n  if (key.startsWith('__Host-')) {\n    if (!opt.secure) {\n      opt.secure = true\n    }\n\n    if (opt.path !== '/') {\n      opt.path = '/'\n    }\n\n    if (opt.domain) {\n      opt.domain = undefined\n    }\n  }\n\n  if (opt && typeof opt.maxAge === 'number' && opt.maxAge >= 0) {\n    if (opt.maxAge > 34560000) {\n      throw new Error(\n        'Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.',\n      )\n    }\n    cookie += `; Max-Age=${Math.floor(opt.maxAge)}`\n  }\n\n  if (opt.domain && opt.prefix !== 'host') {\n    cookie += `; Domain=${opt.domain}`\n  }\n\n  if (opt.path) {\n    cookie += `; Path=${opt.path}`\n  }\n\n  if (opt.expires) {\n    if (opt.expires.getTime() - Date.now() > 34560000_000) {\n      throw new Error(\n        'Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.',\n      )\n    }\n    cookie += `; Expires=${opt.expires.toUTCString()}`\n  }\n\n  if (opt.httpOnly) {\n    cookie += '; HttpOnly'\n  }\n\n  if (opt.secure) {\n    cookie += '; Secure'\n  }\n\n  if (opt.sameSite) {\n    cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`\n  }\n\n  if (opt.partitioned) {\n    if (!opt.secure) {\n      opt.secure = true\n    }\n    cookie += '; Partitioned'\n  }\n\n  return cookie\n}\n\nconst algorithm = { name: 'HMAC', hash: 'SHA-256' }\n\nconst getCryptoKey = async (secret: string | BufferSource) => {\n  const secretBuf = typeof secret === 'string' ? new TextEncoder().encode(secret) : secret\n  return await subtle.importKey('raw', secretBuf, algorithm, false, ['sign', 'verify'])\n}\n\nconst makeSignature = async (value: string, secret: string | BufferSource): Promise<string> => {\n  const key = await getCryptoKey(secret)\n  const signature = await subtle.sign(algorithm.name, key, new TextEncoder().encode(value))\n  // the returned base64 encoded signature will always be 44 characters long and end with one or two equal signs\n  return btoa(String.fromCharCode(...new Uint8Array(signature)))\n}\n\nexport const signCookieValue = async (value: string, secret: string | BufferSource) => {\n  const signature = await makeSignature(value, secret)\n  value = `${value}.${signature}`\n  value = encodeURIComponent(value)\n  value = decodeURIComponent(value)\n  return value\n}\n\nexport const serializeCookie = (key: string, value: string, opt?: CookieOptions) => {\n  value = encodeURIComponent(value)\n  return _serialize(key, value, opt)\n}\n\nexport const serializeSignedCookie = async (\n  key: string,\n  value: string,\n  secret: string,\n  opt?: CookieOptions,\n) => {\n  value = await signCookieValue(value, secret)\n  return _serialize(key, value, opt)\n}\n\nexport const getCookieKey = (key: string, prefix?: CookiePrefixOptions) => {\n  let finalKey = key\n  if (prefix) {\n    if (prefix === 'secure') {\n      finalKey = '__Secure-' + key\n    } else if (prefix === 'host') {\n      finalKey = '__Host-' + key\n    } else {\n      return undefined\n    }\n  }\n  return finalKey\n}\n\nexport function tryDecode(str: string) {\n  try {\n    return str.includes('%') ? decodeURIComponent(str) : str\n  } catch {\n    return str\n  }\n}\n\n/**\n * Parse an HTTP Cookie header string and returning an object of all cookie\n * name-value pairs.\n *\n * Inspired by https://github.com/unjs/cookie-es/blob/main/src/cookie/parse.ts\n *\n * @param str the string representing a `Cookie` header value\n */\nexport function parseCookies(str: string) {\n  if (typeof str !== 'string') {\n    throw new TypeError('argument str must be a string')\n  }\n\n  const cookies: Map<string, string> = new Map()\n\n  let index = 0\n  while (index < str.length) {\n    const eqIdx = str.indexOf('=', index)\n\n    if (eqIdx === -1) {\n      break\n    }\n\n    let endIdx = str.indexOf(';', index)\n\n    if (endIdx === -1) {\n      endIdx = str.length\n    } else if (endIdx < eqIdx) {\n      index = str.lastIndexOf(';', eqIdx - 1) + 1\n      continue\n    }\n\n    const key = str.slice(index, eqIdx).trim()\n    if (!cookies.has(key)) {\n      let val = str.slice(eqIdx + 1, endIdx).trim()\n      if (val.codePointAt(0) === 0x22) {\n        val = val.slice(1, -1)\n      }\n      cookies.set(key, tryDecode(val))\n    }\n\n    index = endIdx + 1\n  }\n\n  return cookies\n}\n\nexport const getSignedCookie = async (\n  key: string,\n  secret: string,\n  headers: Headers,\n  prefix?: CookiePrefixOptions,\n) => {\n  const finalKey = getCookieKey(key, prefix)\n  if (!finalKey) {\n    return null\n  }\n  const cookieHeader = headers.get('cookie')\n  const parsedCookies = cookieHeader ? parseCookies(cookieHeader) : undefined\n  const value = parsedCookies?.get(finalKey)\n  if (!value) {\n    return null\n  }\n  const signatureStartPos = value.lastIndexOf('.')\n  if (signatureStartPos < 1) {\n    return null\n  }\n  const signedValue = value.substring(0, signatureStartPos)\n  const signature = value.substring(signatureStartPos + 1)\n  if (signature.length !== 44 || !signature.endsWith('=')) {\n    return null\n  }\n  const secretKey = await getCryptoKey(secret)\n  const isVerified = await verifySignature(signature, signedValue, secretKey)\n  return isVerified ? signedValue : false\n}\n"],"names":["subtle","verifySignature","base64Signature","value","secret","signatureBinStr","atob","signature","Uint8Array","length","i","len","charCodeAt","verify","algorithm","TextEncoder","encode","e","_serialize","key","opt","cookie","prefix","startsWith","secure","path","domain","undefined","maxAge","Error","Math","floor","expires","getTime","Date","now","toUTCString","httpOnly","sameSite","charAt","toUpperCase","slice","partitioned","name","hash","getCryptoKey","secretBuf","importKey","makeSignature","sign","btoa","String","fromCharCode","signCookieValue","encodeURIComponent","decodeURIComponent","serializeCookie","serializeSignedCookie","getCookieKey","finalKey","tryDecode","str","includes","parseCookies","TypeError","cookies","Map","index","eqIdx","indexOf","endIdx","lastIndexOf","trim","has","val","codePointAt","set","getSignedCookie","headers","cookieHeader","get","parsedCookies","signatureStartPos","signedValue","substring","endsWith","secretKey","isVerified"],"mappings":"AAAA,SAASA,MAAM,QAAQ,WAAU;AA2FjC,OAAO,MAAMC,kBAAkB,OAC7BC,iBACAC,OACAC;IAEA,IAAI;QACF,MAAMC,kBAAkBC,KAAKJ;QAC7B,MAAMK,YAAY,IAAIC,WAAWH,gBAAgBI,MAAM;QACvD,IAAK,IAAIC,IAAI,GAAGC,MAAMN,gBAAgBI,MAAM,EAAEC,IAAIC,KAAKD,IAAK;YAC1DH,SAAS,CAACG,EAAE,GAAGL,gBAAgBO,UAAU,CAACF;QAC5C;QACA,OAAO,MAAMV,OAAOa,MAAM,CAACC,WAAWV,QAAQG,WAAW,IAAIQ,cAAcC,MAAM,CAACb;IACpF,EAAE,OAAOc,GAAG;QACV,OAAO;IACT;AACF,EAAC;AAED,MAAMC,aAAa,CAACC,KAAahB,OAAeiB,MAAqB,CAAC,CAAC;IACrE,IAAIC;IAEJ,IAAID,KAAKE,WAAW,UAAU;QAC5BD,SAAS,GAAG,CAAC,SAAS,EAAEF,KAAK,CAAC,CAAC,EAAEhB,OAAO;IAC1C,OAAO,IAAIiB,KAAKE,WAAW,QAAQ;QACjCD,SAAS,GAAG,CAAC,OAAO,EAAEF,KAAK,CAAC,CAAC,EAAEhB,OAAO;IACxC,OAAO;QACLkB,SAAS,GAAGF,IAAI,CAAC,EAAEhB,OAAO;IAC5B;IAEA,IAAIgB,IAAII,UAAU,CAAC,gBAAgB,CAACH,IAAII,MAAM,EAAE;QAC9CJ,IAAII,MAAM,GAAG;IACf;IAEA,IAAIL,IAAII,UAAU,CAAC,YAAY;QAC7B,IAAI,CAACH,IAAII,MAAM,EAAE;YACfJ,IAAII,MAAM,GAAG;QACf;QAEA,IAAIJ,IAAIK,IAAI,KAAK,KAAK;YACpBL,IAAIK,IAAI,GAAG;QACb;QAEA,IAAIL,IAAIM,MAAM,EAAE;YACdN,IAAIM,MAAM,GAAGC;QACf;IACF;IAEA,IAAIP,OAAO,OAAOA,IAAIQ,MAAM,KAAK,YAAYR,IAAIQ,MAAM,IAAI,GAAG;QAC5D,IAAIR,IAAIQ,MAAM,GAAG,UAAU;YACzB,MAAM,IAAIC,MACR;QAEJ;QACAR,UAAU,CAAC,UAAU,EAAES,KAAKC,KAAK,CAACX,IAAIQ,MAAM,GAAG;IACjD;IAEA,IAAIR,IAAIM,MAAM,IAAIN,IAAIE,MAAM,KAAK,QAAQ;QACvCD,UAAU,CAAC,SAAS,EAAED,IAAIM,MAAM,EAAE;IACpC;IAEA,IAAIN,IAAIK,IAAI,EAAE;QACZJ,UAAU,CAAC,OAAO,EAAED,IAAIK,IAAI,EAAE;IAChC;IAEA,IAAIL,IAAIY,OAAO,EAAE;QACf,IAAIZ,IAAIY,OAAO,CAACC,OAAO,KAAKC,KAAKC,GAAG,KAAK,cAAc;YACrD,MAAM,IAAIN,MACR;QAEJ;QACAR,UAAU,CAAC,UAAU,EAAED,IAAIY,OAAO,CAACI,WAAW,IAAI;IACpD;IAEA,IAAIhB,IAAIiB,QAAQ,EAAE;QAChBhB,UAAU;IACZ;IAEA,IAAID,IAAII,MAAM,EAAE;QACdH,UAAU;IACZ;IAEA,IAAID,IAAIkB,QAAQ,EAAE;QAChBjB,UAAU,CAAC,WAAW,EAAED,IAAIkB,QAAQ,CAACC,MAAM,CAAC,GAAGC,WAAW,KAAKpB,IAAIkB,QAAQ,CAACG,KAAK,CAAC,IAAI;IACxF;IAEA,IAAIrB,IAAIsB,WAAW,EAAE;QACnB,IAAI,CAACtB,IAAII,MAAM,EAAE;YACfJ,IAAII,MAAM,GAAG;QACf;QACAH,UAAU;IACZ;IAEA,OAAOA;AACT;AAEA,MAAMP,YAAY;IAAE6B,MAAM;IAAQC,MAAM;AAAU;AAElD,MAAMC,eAAe,OAAOzC;IAC1B,MAAM0C,YAAY,OAAO1C,WAAW,WAAW,IAAIW,cAAcC,MAAM,CAACZ,UAAUA;IAClF,OAAO,MAAMJ,OAAO+C,SAAS,CAAC,OAAOD,WAAWhC,WAAW,OAAO;QAAC;QAAQ;KAAS;AACtF;AAEA,MAAMkC,gBAAgB,OAAO7C,OAAeC;IAC1C,MAAMe,MAAM,MAAM0B,aAAazC;IAC/B,MAAMG,YAAY,MAAMP,OAAOiD,IAAI,CAACnC,UAAU6B,IAAI,EAAExB,KAAK,IAAIJ,cAAcC,MAAM,CAACb;IAClF,8GAA8G;IAC9G,OAAO+C,KAAKC,OAAOC,YAAY,IAAI,IAAI5C,WAAWD;AACpD;AAEA,OAAO,MAAM8C,kBAAkB,OAAOlD,OAAeC;IACnD,MAAMG,YAAY,MAAMyC,cAAc7C,OAAOC;IAC7CD,QAAQ,GAAGA,MAAM,CAAC,EAAEI,WAAW;IAC/BJ,QAAQmD,mBAAmBnD;IAC3BA,QAAQoD,mBAAmBpD;IAC3B,OAAOA;AACT,EAAC;AAED,OAAO,MAAMqD,kBAAkB,CAACrC,KAAahB,OAAeiB;IAC1DjB,QAAQmD,mBAAmBnD;IAC3B,OAAOe,WAAWC,KAAKhB,OAAOiB;AAChC,EAAC;AAED,OAAO,MAAMqC,wBAAwB,OACnCtC,KACAhB,OACAC,QACAgB;IAEAjB,QAAQ,MAAMkD,gBAAgBlD,OAAOC;IACrC,OAAOc,WAAWC,KAAKhB,OAAOiB;AAChC,EAAC;AAED,OAAO,MAAMsC,eAAe,CAACvC,KAAaG;IACxC,IAAIqC,WAAWxC;IACf,IAAIG,QAAQ;QACV,IAAIA,WAAW,UAAU;YACvBqC,WAAW,cAAcxC;QAC3B,OAAO,IAAIG,WAAW,QAAQ;YAC5BqC,WAAW,YAAYxC;QACzB,OAAO;YACL,OAAOQ;QACT;IACF;IACA,OAAOgC;AACT,EAAC;AAED,OAAO,SAASC,UAAUC,GAAW;IACnC,IAAI;QACF,OAAOA,IAAIC,QAAQ,CAAC,OAAOP,mBAAmBM,OAAOA;IACvD,EAAE,OAAM;QACN,OAAOA;IACT;AACF;AAEA;;;;;;;CAOC,GACD,OAAO,SAASE,aAAaF,GAAW;IACtC,IAAI,OAAOA,QAAQ,UAAU;QAC3B,MAAM,IAAIG,UAAU;IACtB;IAEA,MAAMC,UAA+B,IAAIC;IAEzC,IAAIC,QAAQ;IACZ,MAAOA,QAAQN,IAAIpD,MAAM,CAAE;QACzB,MAAM2D,QAAQP,IAAIQ,OAAO,CAAC,KAAKF;QAE/B,IAAIC,UAAU,CAAC,GAAG;YAChB;QACF;QAEA,IAAIE,SAAST,IAAIQ,OAAO,CAAC,KAAKF;QAE9B,IAAIG,WAAW,CAAC,GAAG;YACjBA,SAAST,IAAIpD,MAAM;QACrB,OAAO,IAAI6D,SAASF,OAAO;YACzBD,QAAQN,IAAIU,WAAW,CAAC,KAAKH,QAAQ,KAAK;YAC1C;QACF;QAEA,MAAMjD,MAAM0C,IAAIpB,KAAK,CAAC0B,OAAOC,OAAOI,IAAI;QACxC,IAAI,CAACP,QAAQQ,GAAG,CAACtD,MAAM;YACrB,IAAIuD,MAAMb,IAAIpB,KAAK,CAAC2B,QAAQ,GAAGE,QAAQE,IAAI;YAC3C,IAAIE,IAAIC,WAAW,CAAC,OAAO,MAAM;gBAC/BD,MAAMA,IAAIjC,KAAK,CAAC,GAAG,CAAC;YACtB;YACAwB,QAAQW,GAAG,CAACzD,KAAKyC,UAAUc;QAC7B;QAEAP,QAAQG,SAAS;IACnB;IAEA,OAAOL;AACT;AAEA,OAAO,MAAMY,kBAAkB,OAC7B1D,KACAf,QACA0E,SACAxD;IAEA,MAAMqC,WAAWD,aAAavC,KAAKG;IACnC,IAAI,CAACqC,UAAU;QACb,OAAO;IACT;IACA,MAAMoB,eAAeD,QAAQE,GAAG,CAAC;IACjC,MAAMC,gBAAgBF,eAAehB,aAAagB,gBAAgBpD;IAClE,MAAMxB,QAAQ8E,eAAeD,IAAIrB;IACjC,IAAI,CAACxD,OAAO;QACV,OAAO;IACT;IACA,MAAM+E,oBAAoB/E,MAAMoE,WAAW,CAAC;IAC5C,IAAIW,oBAAoB,GAAG;QACzB,OAAO;IACT;IACA,MAAMC,cAAchF,MAAMiF,SAAS,CAAC,GAAGF;IACvC,MAAM3E,YAAYJ,MAAMiF,SAAS,CAACF,oBAAoB;IACtD,IAAI3E,UAAUE,MAAM,KAAK,MAAM,CAACF,UAAU8E,QAAQ,CAAC,MAAM;QACvD,OAAO;IACT;IACA,MAAMC,YAAY,MAAMzC,aAAazC;IACrC,MAAMmF,aAAa,MAAMtF,gBAAgBM,WAAW4E,aAAaG;IACjE,OAAOC,aAAaJ,cAAc;AACpC,EAAC"}